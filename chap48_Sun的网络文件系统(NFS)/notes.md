# Sun的网络文件系统(NFS)
分布式客户端/服务器计算的首次使用之一，是在分布式文件系统领域。在这种环境中，有许多客户端机器和一个服务器（或几个）。服务器将数据存储在其磁盘上，客户端通过结构良好的协议消息请求数据。

种设置允许在客户端之间轻松地共享（sharing）数据.

## 基于分布式文件系统

在客户端，客户端应用程序通过客户端文件系统（client-side file system）来访问文件和目录。客户端应用程序向客户端文件系统发出系统调用（system call，例如open()、read()、write()、close()、mkdir()等），以便访问保存在服务器上的文件。因此，对于客户端应用程序，该文件系统似乎与基于磁盘的文件系统没有任何不同，除了性能之外。

这样，分布式文件系统提供了对文件的透明（transparent）访问，这是一个明显的目标.

请注意，客户端内存或客户端磁盘上的后续read()可以缓存（cached）在客户端内存中，在最好的情况下，不需要产生网络流量。

客户端文件系统和文件服务器。它们的行为共同决定了分布式文件系统的行为。现在可以研究一个特定的系统：Sun的网络文件系统（NFS）。

## NFS

最早且相当成功的分布式系统之一是由Sun Microsystems开发的，被称为Sun网络文件系统（或NFS）[S86]。在定义NFS时，Sun采取了一种不寻常的方法：Sun开发了一种开放协议（open protocol），它只是指定了客户端和服务器用于通信的确切消息格式，而不是构建专有的封闭系统。

## 关注点: 简单快速的服务器崩溃恢复

本章将讨论经典的NFS协议（版本2，即NFSv2），这是多年来的标准。转向NFSv3时进行了小的更改，并且在转向NFSv4时进行了更大规模的协议更改。然而，NFSv2既精彩又令人沮丧，因此成为我们关注的焦点。

在NFSv2中，协议的主要目标是“简单快速的服务器崩溃恢复”。

## 快速崩溃恢复的关键: 无状态

通过设计无状态（stateless）协议，NFSv2实现了这个简单的目标。

正如我们上面所暗示的那样，共享状态使崩溃恢复变得复杂。想象一下，在第一次读取完成后，但在客户端发出第二次读取之前，服务器崩溃。服务器启动并再次运行后，客户端会发出第二次读取。

遗憾的是，服务器不知道fd指的是哪个文件。该信息是暂时的（即在内存中），因此在服务器崩溃时丢失。要处理这种情况，客户端和服务器必须具有某种恢复协议（recovery protocol），客户端必须确保在内存中保存足够信息，以便能够告诉服务器，它需要知道的信息（在这个例子中，是文件描述符fd指向文件foo）。

出于这些原因，NFS的设计者决定采用无状态方法：每个客户端操作都包含完成请求所需的所有信息。不需要花哨的崩溃恢复，服务器只是再次开始运行，最糟糕的情况下，客户端可能必须重试请求。

## 关键问题：如何定义无状态文件协议
如何定义网络协议来支持无状态操作？显然，像open()这样的有状态调用不应该讨论。但是，客户端应用程序会调用open()、read()、write()、close()和其他标准API调用，来访问文件和目录。

因此，改进该问题：如何定义协议，让它既无状态，又支持POSIX文件系统API？


## NFSv2协议

理解NFS协议设计的一个关键是理解文件句柄（file handle）。文件句柄用于唯一地描述文件或目录。

可以认为文件句柄有3个重要组件：卷标识符、inode号和世代号。这3项一起构成客户希望访问的文件或目录的唯一标识符。

过在复用inode号时递增它，服务器确保具有旧文件句柄的客户端不会意外地访问新分配的文件。


我们简单强调一下该协议的重要部分。首先，LOOKUP协议消息用于获取文件句柄，然后用于访问文件数据。客户端传递目录文件句柄和要查找的文件的名称，该文件（或目录）的句柄及其属性将从服务器传递回客户端。

属性就是文件系统追踪每个文件的元信息，包括文件创建时间、上次修改时间、大小、所有权和权限信息等，即对文件调用stat()会返回的信息。

## 提示：幂等性很强大

在构建可靠的系统时，幂等性（idempotency）是一种有用的属性。如果一次操作可以发出多次请求，那么处理该操作的失败就要容易得多。你只要重试一下。如果操作不具有幂等性，那么事情就会更困难。

## 从协议到分布式文件系统

你可能会注意到，服务器交互发生的位置。当文件第一次打开时，客户端文件系统发送LOOKUP请求消息。实际上，如果必须访问一个长路径名（例如/home/remzi/foo.txt），客户端将发送3个LOOKUP：一个在/目录中查找home，一个在home中查找remzi，最后一个在remzi中查找foo.txt。


## 利用幂等性操作处理服务器故障

客户端有一个问题：如果服务器没有及时回复，应该怎么做？


如果在收到任何回复之前计时器关闭，则客户端会假定请求尚未处理，并重新发送。如果服务器回复，一切都很好，客户端已经漂亮地处理了问题。

客户端之所以能够简单重试请求（不论什么情况导致了故障），是因为大多数NFS请求有一个重要的特性：它们是幂等的（idempotent）。


更一般地说，任何只读取数据的操作显然都是幂等的。对更新数据的操作必须更仔细地考虑，才能确定它是否具有幂等性。

通过这种方式，客户端可以用统一的方式处理所有超时。如果WRITE请求丢失（上面的第一种情况），客户端将重试它，服务器将执行写入，一切都会好。

一点补充：一些操作很难成为幂等的。

例如，当你尝试创建已存在的目录时，系统会通知你mkdir请求已失败。因此，在NFS中，如果文件服务器收到MKDIR协议消息并成功执行，但回复丢失，则客户端可能会重复它并遇到该故障，实际上该操作第一次成功了，只是在重试时失败。所以，生活并不完美。

## 提高性能: 客户端缓存

另一个问题是：如何才能改善分布式文件系统的性能？

就是客户端缓存（caching）。NFS客户端文件系统缓存文件数据（和元数据）。因此，虽然第一次访问是昂贵的（即它需要网络通信），但后续访问很快就从客户端内存中得到服务。

缓存还可用作写入的临时缓冲区。当客户端应用程序写入文件时，客户端会在数据写入服务器之前，将数据缓存在客户端的内存中（与数据从文件服务器读取的缓存一样）。这种写缓冲（write buffering）是有用的，因为它将应用程序的write()延迟与实际的写入性能分离，即应用程序对write()的调用会立即成功（只是将数据放入客户端文件系统的缓存中），只是稍后才会将数据写入文件服务器。

因此，NFS客户端缓存数据和性能通常很好.

都会引入一个巨大且有趣的挑战，我们称之为缓存一致性问题（cache consistency problem）。

## 缓存一致性问题
- 更新可见性
- 陈旧的缓存


首先，为了解决更新可见性，客户端实现了有时称为“关闭时刷新”（flush-on-close，即close-to-open）的一致性语义。具体来说，当应用程序写入文件并随后关闭文件时，客户端将所有更新（即缓存中的脏页面）刷新到服务器。通过关闭时刷新的一致性，NFS可确保后续从另一个节点打开文件，会看到最新的文件版本。

NFSv2客户端会先检查文件是否已更改，然后再使用其缓存内容.

当Sun最初的团队实现陈旧缓存问题的这个解决方案时，他们意识到一个新问题。突然，NFS服务器充斥着GETATTR请求.

为了解决这种情况（在某种程度上），为每个客户端添加了一个属性缓存（attribute cache）。客户端在访问文件之前仍会验证文件，但大多数情况下只会查看属性缓存以获取属性。首次访问某文件时，该文件的属性被放在缓存中，然后在一定时间（例如3s）后超时。因此，在这3s内，所有文件访问都会断定使用缓存的文件没有问题，并且没有与服务器的网络通信。

## 服务器端写缓冲的隐含意义

在强制写入稳定存储（即磁盘或某些其他持久设备）之前，NFS服务器绝对不会对WRITE协议请求返回成功.

为了避免这个问题，NFS服务器必须在通知客户端成功之前，将每次写入提交到稳定（持久）存储。这样做可以让客户端在写入期间检测服务器故障，从而重试，直到它最终成功。

## 小结

我们已经介绍了NFS分布式文件系统。NFS的核心在于，服务器的故障要能简单快速地恢复。操作的幂等性至关重要，因为客户端可以安全地重试失败的操作，不论服务器是否已执行该请求，都可以这样做。

我们还看到，将缓存引入多客户端、单服务器的系统，如何会让事情变得复杂。具体来说，系统必须解决缓存一致性问题，才能合理地运行。但是，NFS以稍微特别的方式来解决这个问题，偶尔会导致你看到奇怪的行为。最后，我们看到了服务器缓存如何变得棘手：对服务器的写入，在返回成功之前，必须强制写入稳定存储（否则数据可能会丢失）。


