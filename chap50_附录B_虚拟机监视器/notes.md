# 虚拟机监视器
## 简介

具体来说，监视器位于一个或多个操作系统和硬件之间，并为每个运行的操作系统提供控制机器的假象。

然而，在幕后，实际上是监视器在控制硬件，并必须在机器的物理资源上为运行的OS提供多路复用。实际上，VMM作为操作系统的操作系统，但在低得多层次上。

操作系统仍然认为它与物理硬件交互。因此，透明度（transparency）是VMM的主要目标。


## 动机: 为何使用 VMM

在这种情况下，虚拟化使管理员能够将多个操作系统合并（consolidate）到更少的硬件平台上，从而降低成本并简化管理。

因此，通过让开发人员能够在一台计算机上运行多种操作系统类型和版本，虚拟化可以轻松实现这一点。


## 虚拟化 CPU

为了在虚拟机监视器上运行虚拟机（virtual machine，即OS及其应用程序），使用的基本技术是受限直接执行（limited direct execution），这是我们在讨论操作系统如何虚拟化CPU时看到的技术。因此，如果想在VMM之上“启动”新操作系统，只需跳转到第一条指令的地址，并让操作系统开始运行，就这么简单。

假设我们在单个处理器上运行，并且希望在两个虚拟机之间进行多路复用，即在两个操作系统和它们各自的应用程序之间进行多路复用。

非常类似于操作系统在运行进程之间切换的方式（上下文切换，context switch），虚拟机监视器必须在运行的虚拟机之间执行机器切换（machine switch）。因此，当执行这样的切换时，VMM必须保存一个OS的整个机器状态（包括寄存器，PC，并且与上下文切换不同，包括所有特权硬件状态），恢复待运行虚拟机的机器状态，然后跳转到待运行虚拟机的PC，完成切换。

在虚拟化环境中，不允许操作系统执行特权指令，因为它控制机器而不是其下的VMM。因此，VMM必须以某种方式拦截执行特权操作的尝试，从而保持对机器的控制。

执行陷阱指令时，正如之前讨论的那样，它通常会做很多有趣的事情。在我们的示例中，最重要的是它首先将控制转移（即更改PC）到操作系统内定义良好的陷阱处理程序（trap handler）.

操作系统开始启动时，会利用硬件（也是特权操作）建立此类例程的地址，因此在后续的陷阱中，硬件知道从哪里开始运行代码来处理陷阱。在陷阱的同时，硬件还做了另一件至关重要的事情：它将处理器的模式从用户模式（user mode）更改为内核模式（kernel mode）。

## 在虚拟化平台上，事情会更有趣

如果在OS上运行的应用程序希望执行系统调用，它会执行完全相同的操作：执行陷阱指令，并将参数小心地放在栈上（或寄存器中）。但是，VMM控制机器，因此安装了陷阱处理程序的VMM将首先在内核模式下执行。

执行陷阱指令，并将参数小心地放在栈上（或寄存器中）。但是，VMM控制机器，因此安装了陷阱处理程序的VMM将首先在内核模式下执行。

那么VMM应该如何处理这个系统调用呢？

VMM并不真正知道如何（how）处理调用。毕竟，它不知道正在运行的每个操作系统的细节，因此不知道每个调用应该做什么。

然而，VMM知道的是OS的陷阱处理程序在哪里（where）。它知道这一点，因为当操作系统启动时，它试图安装自己的陷阱处理程序。当操作系统这样做时，它试图执行一些特权操作，因此陷入VMM中。那时，VMM记录了必要的信息（即这个OS的陷阱处理程序在内存中的位置）。

现在，当VMM从在给定操作系统上运行的用户进程接收到陷阱时，它确切地知道该做什么：

它跳转到操作系统的陷阱处理程序，并让操作系统按原样处理系统调用。当操作系统完成时，它会执行某种特权指令从陷阱返回（在MIPS上是rett，在x86上是iret），然后再次弹回VMM，然后VMM意识到操作系统正试图从陷阱返回，从而执行一次真正的从陷阱返回，从而将控制返回给用户，并让机器返回用户模式.

换句话说,此时 VMM 的角色就像是用软件来模拟硬件......

当然，由于额外的跳转，虚拟化可能确实会减慢系统调用，从而可能影响性能。

操作系统应该运行在什么模式？它无法在内核模式下运行，因为这可以无限制地访问硬件。因此，它必须以比以前更少的特权模式运行，能够访问自己的数据结构，同时阻止从用户进程访问其数据结构。

在Disco的工作中，Rosenblum及其同事利用MIPS硬件提供的特殊模式（称为管理员模式），非常巧妙地处理了这个问题。在此模式下运行时，仍然无法访问特权指令，但可以访问比在用户模式下更多的内存。操作系统可以将这个额外的内存用于其数据结构，一切都很好。在没有这种模式的硬件上，必须以用户模式运行OS并使用内存保护（页表和TLB），来适当地保护OS的数据结构。

## 虚拟化内存

VMM就像一个操作系统，安排不同的虚拟机运行。当特权级别发生变化时，会发生一些有趣的交互。但我们忽略了很大一部分：VMM如何虚拟化内存？

这个额外的虚拟化层使“物理”内存成为一个虚拟化层，在VMM所谓的机器内存（machine memory）之上，机器内存是系统的真实物理内存。因此，我们现在有一个额外的间接层：每个操作系统通过其每个进程的页表映射虚拟到物理地址，VMM通过它的每个OS页面表，将生成的物理地址映射到底层机器地址。

操作系统之下有虚拟机监视器时，事情变得更有趣了。我们再来看看TLB未命中的流程（参见表B.5的总结）。

当进程进行虚拟内存引用，并导致TLB未命中时，运行的不是OS TLB的未命中处理程序。

实际上，运行的是VMM TLB未命中处理程序，因为VMM是机器的真正特权所有者。

但是，在正常情况下，VMM TLB处理程序不知道如何处理TLB未命中，因此它立即跳转到OS TLB未命中处理程序。


虚拟化系统上的TLB未命中变得比非虚拟化系统更昂贵一点。为了降低这一成本，Disco的设计人员增加了一个VMM级别的“软件TLB”。这种数据结构背后的想法很简单。VMM记录它看到操作系统尝试安装的每个虚拟到物理的映射。

## 信息沟

类似地，VMM通常不太了解操作系统正在做什么或想要什么，这种知识缺乏有时被称为VMM和OS之间的信息沟（information gap），可能导致各种低效率.

但是，如果VMM在两个不同的操作系统下运行，一个在空循环中，另一个在运行有用的用户进程，那么VMM知道一个操作系统处于空闲状态会很有用，这样可以为做有用工作的操作系统提供更多的CPU时间。

## 补充：半虚拟化

在许多情况下，最好是假定，无法为了更好地使用虚拟机监视器而修改操作系统（例如，因为你在不友好的竞争对手的操作系统下运行VMM）。但是，情况并非总是如此。如果可以修改操作系统（正如我们在页面按需置零的示例中所见），它可能在VMM上更高效地运行。运行修改后的操作系统，以便在VMM上运行，这通常称为半虚拟化（para-virtualization），因为VMM提供的虚拟化不是完整的虚拟化，而是需要操作系统更改才能有效运行的部分虚拟化。研究表明，一个设计合理的半虚拟化系统，只需要正确的操作系统更改，就可以接近没有VMM时的效率。

另一个例子是页面按需置零。大多数操作系统在将物理帧映射到进程的地址空间之前将其置零。这样做的原因很简单：安全性。


出于同样的原因，VMM必须将它提供给每个操作系统的页面置零，因此很多时候页面将置零两次，一次由VMM分配给操作系统，一次由操作系统分配给操作系统的一个进程。Disco的作者没有很好地解决这个问题的方法：他们只是简单地将操作系统（IRIX）改为不对页面置零，因为知道已被底层VMM [B+97]置零

一种解决方案是VMM使用推理（一种隐含信息，implicit information）来克服该问题。例如，VMM可以通过注意到OS切换到低功率模式来检测空闲循环。在半虚拟化（para-virtualized）系统中，还有另一种方法，需要更改操作系统。这种更明确的方法虽然难以实施，但却非常有效。

## 小结

虚拟化正在复兴。出于多种原因，用户和管理员希望同时在同一台计算机上运行多个操作系统。

关键是VMM通常透明地（transparently）提供服务，上面的操作系统完全不知道它实际上并没有控制机器的硬件。

VMM使用的关键方法是扩展受限直接执行的概念。通过设置硬件，让VMM能够介入关键事件（例如陷阱），VMM可以完全控制机器资源的分配方式，同时保留操作系统所需的假象。

操作系统为进程执行的操作与VMM为操作系统执行的操作之间存在一些相似之处。它们毕竟都是虚拟化硬件，因此做了一些相同的事情。但是，有一个关键的区别：通过操作系统虚拟化，提供了许多新的抽象和漂亮的接口。

使用VMM级虚拟化，抽象与硬件相同（因此不是很好）。虽然OS和VMM都虚拟化硬件，但它们通过提供完全不同的接口来实现。

与操作系统不同，VMM没有特别打算让硬件更易于使用。

## 提示：使用隐含信息

隐含信息可以成为分层系统中的一个强大工具，在这种系统中很难改变系统之间的接口，但需要更多关于系统不同层的信息。例如，基于块的磁盘设备，可能想了解更多关于它上面的文件系统如何使用它的信息。

同样，应用程序可能想知道文件系统页面缓存中当前有哪些页面，但操作系统不提供访问此信息的API。

在这两种情况下，研究人员都开发了强大的推理技术，来隐式收集所需的信息，而无需在层[AD+01，S+03]之间建立明确的接口。

这些技术在虚拟机监视器中非常有用，它希望了解有关在其上运行的OS的更多信息，而无需在两个层之间使用显式API。




















