# Andrew 文件系统(AFS)
主要目标很简单：扩展（scale）。具体来说，如何设计分布式文件系统（如服务器）可以支持尽可能多的客户端？

在NFS中，缓存一致性很难描述，因为它直接依赖于低级实现细节，包括客户端缓存超时间隔。

在AFS中，缓存一致性很简单且易于理解：当文件打开时，客户端通常会从服务器接收最新的一致副本。

这意味着打开文件时,就会向服务器发起请求,并且获得响应.

## AFSv1

所有AFS版本的基本原则之一，是在访问文件的客户端计算机的本地磁盘（local disk）上，进行全文件缓存（whole-file caching）。

续应用程序read()和write()操作被重定向到存储文件的本地文件系统。因此，这些操作不需要网络通信，速度很快。

注意，与NFS的明显不同，NFS缓存块（不是整个文件，虽然NFS当然可以缓存整个文件的每个块），并且缓存在客户端内存（不是本地磁盘）中。

下次访问该文件时，AFSv1的效率会更高。具体来说，客户端代码首先联系服务器（使用TestAuth协议消息），以确定文件是否已更改。如果未更改，客户端将使用本地缓存的副本，从而避免了网络传输，提高了性能。

## AFSv1的问题

路径查找成本过高。执行Fetch或Store协议请求时，客户端将整个路径名（例如/home/remzi/notes.txt）传递给服务器。为了访问文件，服务器必须执行完整的路径名遍历，首先查看根目录以查找home，然后在home中查找remzi，依此类推，一直沿着路径直到最终定位所需的文件。由于许多客户端同时访问服务器，AFS的设计人员发现服务器花费了大量的CPU时间，只是在沿着目录路径走。

客户端发出太多TestAuth协议消息。与NFS及其过多的GETATTR协议消息非常相似，AFSv1用TestAuth协议信息，生成大量流量，以检查本地文件（或其状态信息）是否有效。因此，服务器花费大量时间，告诉客户端是否可以使用文件的缓存副本。大多数时候，答案是文件没有改变。


## 改进协议

服务器CPU成为系统的瓶颈，每个服务器只能服务20个客户端而不会过载。服务器收到太多的TestAuth消息，当他们收到Fetch或Store消息时，花费了太多时间查找目录层次结构。因此，AFS设计师面临一个问题。

## AFSv2

AFSv2引入了回调（callback）的概念，以减少客户端/服务器交互的数量.

实际上，它假定文件有效，直到服务器另有说明为止。这里类似于轮询（polling）与中断（interrupt）。

FSv2还引入了文件标识符（File Identifier，FID）的概念（类似于NFS文件句柄），替代路径名，来指定客户端感兴趣的文件。AFS中的FID包括卷标识符、文件标识符和“全局唯一标识符”（用于在删除文件时复用卷和文件ID）。

例如，如果客户端访问文件/home/remzi/notes.txt，并且home是挂载在/上的AFS目录（即/是本地根目录，但home及其子目录在AFS中），则客户端将先获取home的目录内容，将它们放在本地磁盘缓存中，然后在home上设置回调。然后，客户端将获取目录remzi，将其放入本地磁盘缓存，并在服务器上设置remzi的回调。最后，客户端将获取notes.txt，将此常规文件缓存在本地磁盘中，设置回调，最后将文件描述符返回给调用应用程序。

即,目录也是文件.

然而，与NFS的关键区别在于，每次获取目录或文件时，AFS客户端都会与服务器建立回调，从而确保服务器通知客户端，其缓存状态发生变化。好处是显而易见的：尽管第一次访问/home/remzi/notes.txt会生成许多客户端—服务器消息（如上所述），但它也会为所有目录以及文件notes.txt建立回调，因此后续访问完全是本地的，根本不需要服务器交互.

## 补充：缓存一致性不能解决所有问题

在讨论分布式文件系统时，很多都是关于文件系统提供的缓存一致性。但是，关于多个客户端访问文件，这种基本一致性并未解决所有问题。例如，如果要构建代码存储库，并且有多个客户端检入和检出代码，则不能简单地依赖底层文件系统来为你完成所有工作。

实际上，你必须使用显式的文件级锁（file-level locking），以确保在发生此类并发访问时，发生“正确”的事情。事实上，任何真正关心并发更新的应用程序，都会增加额外的机制来处理冲突。本章和第48章中描述的基本一致性主要用于随意使用，例如，当用户在不同的客户端登录时，他们希望看到文件的某个合理版本。对这些协议期望过多，会让自己陷入挫败、失望和泪流满面的沮丧。

## 缓存一致性问题

由于回调和全文件缓存，AFS提供的缓存一致性易于描述和理解。有两个重要的情况需要考虑：不同机器上进程的一致性，以及同一台机器上进程的一致性。

AFS自然会采用所谓的“最后写入者胜出”方法（last writer win，也许应该称为“最后关闭者胜出”，last closer win）。

## AFS: 其它改进

AFS为客户端提供了真正的全局命名空间，从而确保所有文件在所有客户端计算机上以相同的方式命名。相比之下，NFS允许每个客户端以它们喜欢的任何方式挂载NFS服务器，因此只有通过公约（以及大量的管理工作），才能让文件在不同客户端上有相似的名字。

## 小结

AFS告诉我们，构建分布式文件系统与我们在NFS中看到的完全不同。

AFS可能在走下坡路。由于NFS是一个开放标准，许多不同的供应商都支持它，它与CIFS（基于Windows的分布式文件系统协议）一起，在市场上占据了主导地位。

实际上，NFSv4现在添加了服务器状态（例如，“open”协议消息），因此与基本AFS协议越来越像。

